{"ast":null,"code":"\"use strict\";\n\nimport _toConsumableArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\nimport { useRoute } from \"./useRoute.js\";\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\n\n/**\n * Infer the param list from the static navigation config.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createElement as _createElement } from \"react\";\nvar MemoizedScreen = /*#__PURE__*/React.memo(__signature__(function (_ref) {\n  var component = _ref.component;\n  var route = useRoute();\n  var children = /*#__PURE__*/React.createElement(component, {\n    route: route\n  });\n  return children;\n}, \"useRoute{route}\", function () {\n  return [useRoute];\n}));\nMemoizedScreen.displayName = 'Memo(Screen)';\nvar getItemsFromScreens = function getItemsFromScreens(Screen, screens) {\n  return Object.entries(screens).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      name = _ref3[0],\n      item = _ref3[1];\n    var component;\n    var props = {};\n    var useIf;\n    var isNavigator = false;\n    if ('screen' in item) {\n      var screen = item.screen,\n        _if = item.if,\n        rest = _objectWithoutProperties(item, [\"screen\", \"if\"]);\n      useIf = _if;\n      props = rest;\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, \"\".concat(name, \"Navigator\"));\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, \"\".concat(name, \"Navigator\"));\n    }\n    if (component == null) {\n      throw new Error(\"Couldn't find a 'screen' property for the screen '\".concat(name, \"'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.\"));\n    }\n    var element = isNavigator ? (/*#__PURE__*/React.createElement(component, {})) : /*#__PURE__*/_jsx(MemoizedScreen, {\n      component: component\n    });\n    return __signature__(function () {\n      var shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return /*#__PURE__*/_jsx(Screen, _objectSpread({\n        name: name\n      }, props, {\n        children: function children() {\n          return element;\n        }\n      }), name);\n    }, \"useIf{}\", function () {\n      return [useIf];\n    });\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(tree, displayName) {\n  var Navigator = tree.Navigator,\n    Group = tree.Group,\n    Screen = tree.Screen,\n    config = tree.config;\n  var screens = config.screens,\n    groups = config.groups,\n    rest = _objectWithoutProperties(config, [\"screens\", \"groups\"]);\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  var items = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (var key in config) {\n    if (key === 'screens' && screens) {\n      items.push.apply(items, _toConsumableArray(getItemsFromScreens(Screen, screens)));\n    }\n    if (key === 'groups' && groups) {\n      items.push.apply(items, _toConsumableArray(Object.entries(groups).map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          key = _ref5[0],\n          _ref5$ = _ref5[1],\n          useIf = _ref5$.if,\n          group = _objectWithoutProperties(_ref5$, [\"if\"]);\n        var groupItems = getItemsFromScreens(Screen, group.screens);\n        return __signature__(function () {\n          // Call unconditionally since screen configs may contain `useIf` hooks\n          var children = groupItems.map(function (item) {\n            return item();\n          });\n          var shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return /*#__PURE__*/_createElement(Group, _objectSpread({\n            navigationKey: key\n          }, group, {\n            key: key\n          }), children);\n        }, \"useIf{}\", function () {\n          return [useIf];\n        });\n      })));\n    }\n  }\n  var NavigatorComponent = function NavigatorComponent() {\n    var children = items.map(function (item) {\n      return item();\n    });\n    return /*#__PURE__*/_jsx(Navigator, _objectSpread({}, rest, {\n      children: children\n    }));\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(tree, options, auto) {\n  var initialScreenConfig;\n  var createPathConfigForTree = function createPathConfigForTree(t, o, skipInitialDetection) {\n    var createPathConfigForScreens = function createPathConfigForScreens(screens, initialRouteName) {\n      return Object.fromEntries(Object.entries(screens)\n      // Re-order to move the initial route to the front\n      // This way we can detect the initial route correctly\n      .sort(function (_ref6, _ref7) {\n        var _ref8 = _slicedToArray(_ref6, 1),\n          a = _ref8[0];\n        var _ref9 = _slicedToArray(_ref7, 1),\n          b = _ref9[0];\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(function (_ref10) {\n        var _ref11 = _slicedToArray(_ref10, 2),\n          key = _ref11[0],\n          item = _ref11[1];\n        var screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n          if (typeof screenConfig.path === 'string') {\n            screenConfig.path = screenConfig.path.replace(/^\\//, '') // Remove extra leading slash\n            .replace(/\\/$/, ''); // Remove extra trailing slash\n          }\n        }\n        var screens;\n        var skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';\n        if ('config' in item) {\n          screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens &&\n        // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n        !('linking' in item && item.linking == null)) {\n          if (screenConfig.path != null) {\n            if (!skipInitialDetection && screenConfig.path === '') {\n              // We encounter a leaf screen with empty path,\n              // Clear the initial screen config as it's not needed anymore\n              initialScreenConfig = undefined;\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(function (_ref12) {\n        var _ref13 = _slicedToArray(_ref12, 2),\n          screen = _ref13[1];\n        return Object.keys(screen).length > 0;\n      }));\n    };\n    var screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (var key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(function (_ref14) {\n          var _ref15 = _slicedToArray(_ref14, 2),\n            group = _ref15[1];\n          Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  var screens = createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(MemoizedScreen, \"MemoizedScreen\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\StaticNavigation.js\");\n  reactHotLoader.register(getItemsFromScreens, \"getItemsFromScreens\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\StaticNavigation.js\");\n  reactHotLoader.register(createComponentForStaticNavigation, \"createComponentForStaticNavigation\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\StaticNavigation.js\");\n  reactHotLoader.register(createPathConfigForStaticNavigation, \"createPathConfigForStaticNavigation\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\StaticNavigation.js\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}