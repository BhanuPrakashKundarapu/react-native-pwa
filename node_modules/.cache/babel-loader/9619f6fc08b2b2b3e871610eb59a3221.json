{"ast":null,"code":"\"use strict\";\n\nimport _objectSpread from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\nimport { CommonActions } from '@react-navigation/routers';\nimport * as React from 'react';\nimport useLatestCallback from 'use-latest-callback';\nimport { checkDuplicateRouteNames } from \"./checkDuplicateRouteNames.js\";\nimport { checkSerializable } from \"./checkSerializable.js\";\nimport { NOT_INITIALIZED_ERROR } from \"./createNavigationContainerRef.js\";\nimport { DeprecatedNavigationInChildContext } from \"./DeprecatedNavigationInChildContext.js\";\nimport { EnsureSingleNavigator } from \"./EnsureSingleNavigator.js\";\nimport { findFocusedRoute } from \"./findFocusedRoute.js\";\nimport { NavigationBuilderContext } from \"./NavigationBuilderContext.js\";\nimport { NavigationContainerRefContext } from \"./NavigationContainerRefContext.js\";\nimport { NavigationIndependentTreeContext } from \"./NavigationIndependentTreeContext.js\";\nimport { NavigationStateContext } from \"./NavigationStateContext.js\";\nimport { ThemeProvider } from \"./theming/ThemeProvider.js\";\nimport { UnhandledActionContext } from \"./UnhandledActionContext.js\";\nimport { useChildListeners } from \"./useChildListeners.js\";\nimport { useEventEmitter } from \"./useEventEmitter.js\";\nimport { useKeyedChildListeners } from \"./useKeyedChildListeners.js\";\nimport { useNavigationIndependentTree } from \"./useNavigationIndependentTree.js\";\nimport { useOptionsGetters } from \"./useOptionsGetters.js\";\nimport { useSyncState } from \"./useSyncState.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar serializableWarnings = [];\nvar duplicateNameWarnings = [];\n\n/**\n * Remove `key` and `routeNames` from the state objects recursively to get partial state.\n *\n * @param state Initial state object.\n */\nvar getPartialState = function getPartialState(state) {\n  if (state === undefined) {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var key = state.key,\n    routeNames = state.routeNames,\n    partialState = _objectWithoutProperties(state, [\"key\", \"routeNames\"]);\n  return _objectSpread({}, partialState, {\n    stale: true,\n    routes: state.routes.map(function (route) {\n      if (route.state === undefined) {\n        return route;\n      }\n      return _objectSpread({}, route, {\n        state: getPartialState(route.state)\n      });\n    })\n  });\n};\n\n/**\n * Container component which holds the navigation state.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree.\n * @param props.onReady Callback which is called after the navigation tree mounts.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.onUnhandledAction Callback which is called when an action is not handled.\n * @param props.theme Theme object for the UI elements.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nexport var BaseNavigationContainer = /*#__PURE__*/React.forwardRef(__signature__(function BaseNavigationContainer(_ref, ref) {\n  var initialState = _ref.initialState,\n    onStateChange = _ref.onStateChange,\n    onReady = _ref.onReady,\n    onUnhandledAction = _ref.onUnhandledAction,\n    _ref$navigationInChil = _ref.navigationInChildEnabled,\n    navigationInChildEnabled = _ref$navigationInChil === void 0 ? false : _ref$navigationInChil,\n    theme = _ref.theme,\n    children = _ref.children;\n  var parent = React.useContext(NavigationStateContext);\n  var independent = useNavigationIndependentTree();\n  if (!parent.isDefault && !independent) {\n    throw new Error(\"Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, wrap the container in 'NavigationIndependentTree' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.\");\n  }\n  var _useSyncState = useSyncState(function () {\n      return getPartialState(initialState == null ? undefined : initialState);\n    }),\n    state = _useSyncState.state,\n    getState = _useSyncState.getState,\n    setState = _useSyncState.setState,\n    scheduleUpdate = _useSyncState.scheduleUpdate,\n    flushUpdates = _useSyncState.flushUpdates;\n  var isFirstMountRef = React.useRef(true);\n  var navigatorKeyRef = React.useRef();\n  var getKey = React.useCallback(function () {\n    return navigatorKeyRef.current;\n  }, []);\n  var setKey = React.useCallback(function (key) {\n    navigatorKeyRef.current = key;\n  }, []);\n  var _useChildListeners = useChildListeners(),\n    listeners = _useChildListeners.listeners,\n    addListener = _useChildListeners.addListener;\n  var _useKeyedChildListene = useKeyedChildListeners(),\n    keyedListeners = _useKeyedChildListene.keyedListeners,\n    addKeyedListener = _useKeyedChildListene.addKeyedListener;\n  var dispatch = useLatestCallback(function (action) {\n    if (listeners.focus[0] == null) {\n      console.error(NOT_INITIALIZED_ERROR);\n    } else {\n      listeners.focus[0](function (navigation) {\n        return navigation.dispatch(action);\n      });\n    }\n  });\n  var canGoBack = useLatestCallback(function () {\n    if (listeners.focus[0] == null) {\n      return false;\n    }\n    var _listeners$focus$ = listeners.focus[0](function (navigation) {\n        return navigation.canGoBack();\n      }),\n      result = _listeners$focus$.result,\n      handled = _listeners$focus$.handled;\n    if (handled) {\n      return result;\n    } else {\n      return false;\n    }\n  });\n  var resetRoot = useLatestCallback(function (state) {\n    var target = state?.key ?? keyedListeners.getState.root?.().key;\n    if (target == null) {\n      console.error(NOT_INITIALIZED_ERROR);\n    } else {\n      listeners.focus[0](function (navigation) {\n        return navigation.dispatch(_objectSpread({}, CommonActions.reset(state), {\n          target: target\n        }));\n      });\n    }\n  });\n  var getRootState = useLatestCallback(function () {\n    return keyedListeners.getState.root?.();\n  });\n  var getCurrentRoute = useLatestCallback(function () {\n    var state = getRootState();\n    if (state == null) {\n      return undefined;\n    }\n    var route = findFocusedRoute(state);\n    return route;\n  });\n  var isReady = useLatestCallback(function () {\n    return listeners.focus[0] != null;\n  });\n  var emitter = useEventEmitter();\n  var _useOptionsGetters = useOptionsGetters({}),\n    addOptionsGetter = _useOptionsGetters.addOptionsGetter,\n    getCurrentOptions = _useOptionsGetters.getCurrentOptions;\n  var navigation = React.useMemo(function () {\n    return _objectSpread({}, Object.keys(CommonActions).reduce(function (acc, name) {\n      acc[name] = function () {\n        return (\n          // @ts-expect-error: this is ok\n          dispatch(CommonActions[name].apply(CommonActions, arguments))\n        );\n      };\n      return acc;\n    }, {}), emitter.create('root'), {\n      dispatch: dispatch,\n      resetRoot: resetRoot,\n      isFocused: function isFocused() {\n        return true;\n      },\n      canGoBack: canGoBack,\n      getParent: function getParent() {\n        return undefined;\n      },\n      getState: getState,\n      getRootState: getRootState,\n      getCurrentRoute: getCurrentRoute,\n      getCurrentOptions: getCurrentOptions,\n      isReady: isReady,\n      setOptions: function setOptions() {\n        throw new Error('Cannot call setOptions outside a screen');\n      }\n    });\n  }, [canGoBack, dispatch, emitter, getCurrentOptions, getCurrentRoute, getRootState, getState, isReady, resetRoot]);\n  React.useImperativeHandle(ref, function () {\n    return navigation;\n  }, [navigation]);\n  var onDispatchAction = useLatestCallback(function (action, noop) {\n    emitter.emit({\n      type: '__unsafe_action__',\n      data: {\n        action: action,\n        noop: noop,\n        stack: stackRef.current\n      }\n    });\n  });\n  var lastEmittedOptionsRef = React.useRef();\n  var onOptionsChange = useLatestCallback(function (options) {\n    if (lastEmittedOptionsRef.current === options) {\n      return;\n    }\n    lastEmittedOptionsRef.current = options;\n    emitter.emit({\n      type: 'options',\n      data: {\n        options: options\n      }\n    });\n  });\n  var stackRef = React.useRef();\n  var builderContext = React.useMemo(function () {\n    return {\n      addListener: addListener,\n      addKeyedListener: addKeyedListener,\n      onDispatchAction: onDispatchAction,\n      onOptionsChange: onOptionsChange,\n      scheduleUpdate: scheduleUpdate,\n      flushUpdates: flushUpdates,\n      stackRef: stackRef\n    };\n  }, [addListener, addKeyedListener, onDispatchAction, onOptionsChange, scheduleUpdate, flushUpdates]);\n  var isInitialRef = React.useRef(true);\n  var getIsInitial = React.useCallback(function () {\n    return isInitialRef.current;\n  }, []);\n  var context = React.useMemo(function () {\n    return {\n      state: state,\n      getState: getState,\n      setState: setState,\n      getKey: getKey,\n      setKey: setKey,\n      getIsInitial: getIsInitial,\n      addOptionsGetter: addOptionsGetter\n    };\n  }, [state, getState, setState, getKey, setKey, getIsInitial, addOptionsGetter]);\n  var onReadyRef = React.useRef(onReady);\n  var onStateChangeRef = React.useRef(onStateChange);\n  React.useEffect(function () {\n    isInitialRef.current = false;\n    onStateChangeRef.current = onStateChange;\n    onReadyRef.current = onReady;\n  });\n  var onReadyCalledRef = React.useRef(false);\n  React.useEffect(function () {\n    if (!onReadyCalledRef.current && isReady()) {\n      onReadyCalledRef.current = true;\n      onReadyRef.current?.();\n    }\n  }, [state, isReady]);\n  React.useEffect(function () {\n    var hydratedState = getRootState();\n    if (process.env.NODE_ENV !== 'production') {\n      if (hydratedState !== undefined) {\n        var serializableResult = checkSerializable(hydratedState);\n        if (!serializableResult.serializable) {\n          var location = serializableResult.location,\n            reason = serializableResult.reason;\n          var path = '';\n          var pointer = hydratedState;\n          var params = false;\n          for (var i = 0; i < location.length; i++) {\n            var curr = location[i];\n            var prev = location[i - 1];\n            pointer = pointer[curr];\n            if (!params && curr === 'state') {\n              continue;\n            } else if (!params && curr === 'routes') {\n              if (path) {\n                path += ' > ';\n              }\n            } else if (!params && typeof curr === 'number' && prev === 'routes') {\n              path += pointer?.name;\n            } else if (!params) {\n              path += \" > \".concat(curr);\n              params = true;\n            } else {\n              if (typeof curr === 'number' || /^[0-9]+$/.test(curr)) {\n                path += \"[\".concat(curr, \"]\");\n              } else if (/^[a-z$_]+$/i.test(curr)) {\n                path += \".\".concat(curr);\n              } else {\n                path += \"[\".concat(JSON.stringify(curr), \"]\");\n              }\n            }\n          }\n          var message = \"Non-serializable values were found in the navigation state. Check:\\n\\n\".concat(path, \" (\").concat(reason, \")\\n\\nThis can break usage such as persisting and restoring state. This might happen if you passed non-serializable values such as function, class instances etc. in params. If you need to use components with callbacks in your options, you can use 'navigation.setOptions' instead. See https://reactnavigation.org/docs/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state for more details.\");\n          if (!serializableWarnings.includes(message)) {\n            serializableWarnings.push(message);\n            console.warn(message);\n          }\n        }\n        var duplicateRouteNamesResult = checkDuplicateRouteNames(hydratedState);\n        if (duplicateRouteNamesResult.length) {\n          var _message = \"Found screens with the same name nested inside one another. Check:\\n\".concat(duplicateRouteNamesResult.map(function (locations) {\n            return \"\\n\".concat(locations.join(', '));\n          }), \"\\n\\nThis can cause confusing behavior during navigation. Consider using unique names for each screen instead.\");\n          if (!duplicateNameWarnings.includes(_message)) {\n            duplicateNameWarnings.push(_message);\n            console.warn(_message);\n          }\n        }\n      }\n    }\n    emitter.emit({\n      type: 'state',\n      data: {\n        state: state\n      }\n    });\n    if (!isFirstMountRef.current && onStateChangeRef.current) {\n      onStateChangeRef.current(hydratedState);\n    }\n    isFirstMountRef.current = false;\n  }, [getRootState, emitter, state]);\n  var defaultOnUnhandledAction = useLatestCallback(function (action) {\n    if (process.env.NODE_ENV === 'production') {\n      return;\n    }\n    var payload = action.payload;\n    var message = \"The action '\".concat(action.type, \"'\").concat(payload ? \" with payload \".concat(JSON.stringify(action.payload)) : '', \" was not handled by any navigator.\");\n    switch (action.type) {\n      case 'NAVIGATE':\n      case 'PUSH':\n      case 'REPLACE':\n      case 'JUMP_TO':\n        if (payload?.name) {\n          message += \"\\n\\nDo you have a screen named '\".concat(payload.name, \"'?\\n\\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.\\n\\nIf you're using conditional rendering, navigation will happen automatically and you shouldn't navigate manually.\");\n        } else {\n          message += \"\\n\\nYou need to pass the name of the screen to navigate to.\\n\\nSee https://reactnavigation.org/docs/navigation-actions for usage.\";\n        }\n        break;\n      case 'GO_BACK':\n      case 'POP':\n      case 'POP_TO_TOP':\n        message += \"\\n\\nIs there any screen to go back to?\";\n        break;\n      case 'OPEN_DRAWER':\n      case 'CLOSE_DRAWER':\n      case 'TOGGLE_DRAWER':\n        message += \"\\n\\nIs your screen inside a Drawer navigator?\";\n        break;\n    }\n    message += \"\\n\\nThis is a development-only warning and won't be shown in production.\";\n    console.error(message);\n  });\n  return /*#__PURE__*/_jsx(NavigationIndependentTreeContext.Provider, {\n    value: false,\n    children: /*#__PURE__*/_jsx(NavigationContainerRefContext.Provider, {\n      value: navigation,\n      children: /*#__PURE__*/_jsx(NavigationBuilderContext.Provider, {\n        value: builderContext,\n        children: /*#__PURE__*/_jsx(NavigationStateContext.Provider, {\n          value: context,\n          children: /*#__PURE__*/_jsx(UnhandledActionContext.Provider, {\n            value: onUnhandledAction ?? defaultOnUnhandledAction,\n            children: /*#__PURE__*/_jsx(DeprecatedNavigationInChildContext.Provider, {\n              value: navigationInChildEnabled,\n              children: /*#__PURE__*/_jsx(EnsureSingleNavigator, {\n                children: /*#__PURE__*/_jsx(ThemeProvider, {\n                  value: theme,\n                  children: children\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n}, \"useContext{parent}\\nuseNavigationIndependentTree{independent}\\nuseSyncState{{\\n    state,\\n    getState,\\n    setState,\\n    scheduleUpdate,\\n    flushUpdates\\n  }}\\nuseRef{isFirstMountRef}\\nuseRef{navigatorKeyRef}\\nuseCallback{getKey}\\nuseCallback{setKey}\\nuseChildListeners{{\\n    listeners,\\n    addListener\\n  }}\\nuseKeyedChildListeners{{\\n    keyedListeners,\\n    addKeyedListener\\n  }}\\nuseLatestCallback{dispatch}\\nuseLatestCallback{canGoBack}\\nuseLatestCallback{resetRoot}\\nuseLatestCallback{getRootState}\\nuseLatestCallback{getCurrentRoute}\\nuseLatestCallback{isReady}\\nuseEventEmitter{emitter}\\nuseOptionsGetters{{\\n    addOptionsGetter,\\n    getCurrentOptions\\n  }}\\nuseMemo{navigation}\\nuseImperativeHandle{}\\nuseLatestCallback{onDispatchAction}\\nuseRef{lastEmittedOptionsRef}\\nuseLatestCallback{onOptionsChange}\\nuseRef{stackRef}\\nuseMemo{builderContext}\\nuseRef{isInitialRef}\\nuseCallback{getIsInitial}\\nuseMemo{context}\\nuseRef{onReadyRef}\\nuseRef{onStateChangeRef}\\nuseEffect{}\\nuseRef{onReadyCalledRef}\\nuseEffect{}\\nuseEffect{}\\nuseLatestCallback{defaultOnUnhandledAction}\", function () {\n  return [useNavigationIndependentTree, useSyncState, useChildListeners, useKeyedChildListeners, useLatestCallback, useLatestCallback, useLatestCallback, useLatestCallback, useLatestCallback, useLatestCallback, useEventEmitter, useOptionsGetters, React.useImperativeHandle, useLatestCallback, useLatestCallback, useLatestCallback];\n}));\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(serializableWarnings, \"serializableWarnings\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\BaseNavigationContainer.js\");\n  reactHotLoader.register(duplicateNameWarnings, \"duplicateNameWarnings\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\BaseNavigationContainer.js\");\n  reactHotLoader.register(getPartialState, \"getPartialState\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\BaseNavigationContainer.js\");\n  reactHotLoader.register(BaseNavigationContainer, \"BaseNavigationContainer\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\BaseNavigationContainer.js\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}