{"ast":null,"code":"\"use strict\";\n\nimport _slicedToArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _defineProperty from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\nimport { arrayStartsWith } from \"./arrayStartsWith.js\";\nimport { findFocusedRoute } from \"./findFocusedRoute.js\";\nimport { getPatternParts } from \"./getPatternParts.js\";\nimport { isArrayEqual } from \"./isArrayEqual.js\";\nimport { validatePathConfig } from \"./validatePathConfig.js\";\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath(path, options) {\n  var _getConfigResources = getConfigResources(options),\n    initialRoutes = _getConfigResources.initialRoutes,\n    configs = _getConfigResources.configs;\n  var screens = options?.screens;\n  var remaining = path.replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n  .replace(/^\\//, '') // Remove extra leading slash\n  .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : \"\".concat(remaining, \"/\");\n  var prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    var normalizedPrefix = prefix.endsWith('/') ? prefix : \"\".concat(prefix, \"/\");\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    var _routes = remaining.split('/').filter(Boolean).map(function (segment) {\n      var name = decodeURIComponent(segment);\n      return {\n        name: name\n      };\n    });\n    if (_routes.length) {\n      return createNestedStateObject(path, _routes, initialRoutes);\n    }\n    return undefined;\n  }\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    var match = configs.find(function (config) {\n      return config.segments.join('/') === '';\n    });\n    if (match) {\n      return createNestedStateObject(path, match.routeNames.map(function (name) {\n        return {\n          name: name\n        };\n      }), initialRoutes, configs);\n    }\n    return undefined;\n  }\n  var result;\n  var current;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs),\n    routes = _matchAgainstConfigs.routes,\n    remainingPath = _matchAgainstConfigs.remainingPath;\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n  if (current == null || result == null) {\n    return undefined;\n  }\n  return result;\n}\n\n/**\n * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.\n */\nvar cachedConfigResources = new WeakMap();\nfunction getConfigResources(options) {\n  if (!options) return prepareConfigResources();\n  var cached = cachedConfigResources.get(options);\n  if (cached) return cached;\n  var resources = prepareConfigResources(options);\n  cachedConfigResources.set(options, resources);\n  return resources;\n}\nfunction prepareConfigResources(options) {\n  if (options) {\n    validatePathConfig(options);\n  }\n  var initialRoutes = getInitialRoutes(options);\n  var configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);\n  checkForDuplicatedConfigs(configs);\n  var configWithRegexes = getConfigsWithRegexes(configs);\n  return {\n    initialRoutes: initialRoutes,\n    configs: configs,\n    configWithRegexes: configWithRegexes\n  };\n}\nfunction getInitialRoutes(options) {\n  var initialRoutes = [];\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: []\n    });\n  }\n  return initialRoutes;\n}\nfunction getSortedNormalizedConfigs(initialRoutes) {\n  var _ref;\n  var screens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Create a normalized configs array which will be easier to use\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(screens).map(function (key) {\n    return createNormalizedConfigs(key, screens, initialRoutes, [], [], []);\n  }))).sort(function (a, b) {\n    // Sort config from most specific to least specific:\n    // - more segments\n    // - static segments\n    // - params with regex\n    // - regular params\n    // - wildcard\n\n    // If 2 patterns are same, move the one with less route names up\n    // This is an error state, so it's only useful for consistent error messages\n    if (isArrayEqual(a.segments, b.segments)) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n\n    // If one of the patterns starts with the other, it's more exhaustive\n    // So move it up\n    if (arrayStartsWith(a.segments, b.segments)) {\n      return -1;\n    }\n    if (arrayStartsWith(b.segments, a.segments)) {\n      return 1;\n    }\n    for (var i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {\n      // if b is longer, b gets higher priority\n      if (a.segments[i] == null) {\n        return 1;\n      }\n\n      // if a is longer, a gets higher priority\n      if (b.segments[i] == null) {\n        return -1;\n      }\n      var aWildCard = a.segments[i] === '*';\n      var bWildCard = b.segments[i] === '*';\n      var aParam = a.segments[i].startsWith(':');\n      var bParam = b.segments[i].startsWith(':');\n      var aRegex = aParam && a.segments[i].includes('(');\n      var bRegex = bParam && b.segments[i].includes('(');\n\n      // if both are wildcard or regex, we compare next component\n      if (aWildCard && bWildCard || aRegex && bRegex) {\n        continue;\n      }\n\n      // if only a is wildcard, b gets higher priority\n      if (aWildCard && !bWildCard) {\n        return 1;\n      }\n\n      // if only b is wildcard, a gets higher priority\n      if (bWildCard && !aWildCard) {\n        return -1;\n      }\n\n      // If only a has a param, b gets higher priority\n      if (aParam && !bParam) {\n        return 1;\n      }\n\n      // If only b has a param, a gets higher priority\n      if (bParam && !aParam) {\n        return -1;\n      }\n\n      // if only a has regex, a gets higher priority\n      if (aRegex && !bRegex) {\n        return -1;\n      }\n\n      // if only b has regex, b gets higher priority\n      if (bRegex && !aRegex) {\n        return 1;\n      }\n    }\n    return a.segments.length - b.segments.length;\n  });\n}\nfunction checkForDuplicatedConfigs(configs) {\n  // Check for duplicate patterns in the config\n  configs.reduce(function (acc, config) {\n    var pattern = config.segments.join('/');\n    if (acc[pattern]) {\n      var a = acc[pattern].routeNames;\n      var b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      var intersects = a.length > b.length ? b.every(function (it, i) {\n        return a[i] === it;\n      }) : a.every(function (it, i) {\n        return b[i] === it;\n      });\n      if (!intersects) {\n        throw new Error(\"Found conflicting screens with the same pattern. The pattern '\".concat(pattern, \"' resolves to both '\").concat(a.join(' > '), \"' and '\").concat(b.join(' > '), \"'. Patterns must be unique and cannot resolve to more than one screen.\"));\n      }\n    }\n    return Object.assign(acc, _defineProperty({}, pattern, config));\n  }, {});\n}\nfunction getConfigsWithRegexes(configs) {\n  return configs.map(function (c) {\n    return _objectSpread({}, c, {\n      // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined\n    });\n  });\n}\nvar matchAgainstConfigs = function matchAgainstConfigs(remaining, configs) {\n  var routes;\n  var remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    var _loop2 = function _loop2() {\n      var config = _step.value;\n      if (!config.regex) {\n        return \"continue\";\n      }\n      var match = remainingPath.match(config.regex);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routes = config.routeNames.map(function (routeName) {\n          var routeConfig = configs.find(function (c) {\n            // Check matching name AND pattern in case same screen is used at different levels in config\n            return c.screen === routeName && arrayStartsWith(config.segments, c.segments);\n          });\n          var params = routeConfig && match.groups ? Object.fromEntries(Object.entries(match.groups).map(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2),\n              key = _ref3[0],\n              value = _ref3[1];\n            var index = Number(key.replace('param_', ''));\n            var param = routeConfig.params.find(function (it) {\n              return it.index === index;\n            });\n            if (param?.screen === routeName && param?.name) {\n              return [param.name, value];\n            }\n            return null;\n          }).filter(function (it) {\n            return it != null;\n          }).map(function (_ref4) {\n            var _ref5 = _slicedToArray(_ref4, 2),\n              key = _ref5[0],\n              value = _ref5[1];\n            if (value == null) {\n              return [key, undefined];\n            }\n            var decoded = decodeURIComponent(value);\n            var parsed = routeConfig.parse?.[key] ? routeConfig.parse[key](decoded) : decoded;\n            return [key, parsed];\n          })) : undefined;\n          if (params && Object.keys(params).length) {\n            return {\n              name: routeName,\n              params: params\n            };\n          }\n          return {\n            name: routeName\n          };\n        });\n        remainingPath = remainingPath.replace(match[0], '');\n        return \"break\";\n      }\n    };\n    _loop: for (var _iterator = configs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ret = _loop2();\n      switch (_ret) {\n        case \"continue\":\n          continue;\n        case \"break\":\n          break _loop;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return {\n    routes: routes,\n    remainingPath: remainingPath\n  };\n};\nvar createNormalizedConfigs = function createNormalizedConfigs(screen, routeConfig, initials, paths, parentScreens, routeNames) {\n  var configs = [];\n  routeNames.push(screen);\n  parentScreens.push(screen);\n  var config = routeConfig[screen];\n  if (typeof config === 'string') {\n    paths.push({\n      screen: screen,\n      path: config\n    });\n    configs.push(createConfigItem(screen, _toConsumableArray(routeNames), _toConsumableArray(paths)));\n  } else if (typeof config === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path == null) {\n        throw new Error(\"Screen '\".concat(screen, \"' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"));\n      }\n\n      // We should add alias configs after the main config\n      // So unless they are more specific, main config will be matched first\n      var aliasConfigs = [];\n      if (config.alias) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = config.alias[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var alias = _step2.value;\n            if (typeof alias === 'string') {\n              aliasConfigs.push(createConfigItem(screen, _toConsumableArray(routeNames), [].concat(_toConsumableArray(paths), [{\n                screen: screen,\n                path: alias\n              }]), config.parse));\n            } else if (typeof alias === 'object') {\n              aliasConfigs.push(createConfigItem(screen, _toConsumableArray(routeNames), alias.exact ? [{\n                screen: screen,\n                path: alias.path\n              }] : [].concat(_toConsumableArray(paths), [{\n                screen: screen,\n                path: alias.path\n              }]), alias.parse));\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n      if (config.exact) {\n        // If it's an exact path, we don't need to keep track of the parent screens\n        // So we can clear it\n        paths.length = 0;\n      }\n      paths.push({\n        screen: screen,\n        path: config.path\n      });\n      configs.push(createConfigItem(screen, _toConsumableArray(routeNames), _toConsumableArray(paths), config.parse));\n      configs.push.apply(configs, aliasConfigs);\n    }\n    if (typeof config !== 'string' && typeof config.path !== 'string' && config.alias?.length) {\n      throw new Error(\"Screen '\".concat(screen, \"' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.\"));\n    }\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens: parentScreens\n        });\n      }\n      Object.keys(config.screens).forEach(function (nestedConfig) {\n        var result = createNormalizedConfigs(nestedConfig, config.screens, initials, _toConsumableArray(paths), _toConsumableArray(parentScreens), routeNames);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n  routeNames.pop();\n  return configs;\n};\nvar createConfigItem = function createConfigItem(screen, routeNames, paths, parse) {\n  var parts = [];\n\n  // Parse the path string into parts for easier matching\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n  try {\n    var _loop3 = function _loop3() {\n      var _step3$value = _step3.value,\n        screen = _step3$value.screen,\n        path = _step3$value.path;\n      parts.push.apply(parts, _toConsumableArray(getPatternParts(path).map(function (part) {\n        return _objectSpread({}, part, {\n          screen: screen\n        });\n      })));\n    };\n    for (var _iterator3 = paths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      _loop3();\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n  var regex = parts.length ? new RegExp(\"^(\".concat(parts.map(function (it, i) {\n    if (it.param) {\n      var reg = it.regex || '[^/]+';\n      return \"(((?<param_\".concat(i, \">\").concat(reg, \")\\\\/)\").concat(it.optional ? '?' : '', \")\");\n    }\n    return \"\".concat(it.segment === '*' ? '.*' : escape(it.segment), \"\\\\/\");\n  }).join(''), \")$\")) : undefined;\n  var segments = parts.map(function (it) {\n    return it.segment;\n  });\n  var params = parts.map(function (it, i) {\n    return it.param ? {\n      index: i,\n      screen: it.screen,\n      name: it.param\n    } : null;\n  }).filter(function (it) {\n    return it != null;\n  });\n  return {\n    screen: screen,\n    regex: regex,\n    segments: segments,\n    params: params,\n    routeNames: routeNames,\n    parse: parse\n  };\n};\nvar findParseConfigForRoute = function findParseConfigForRoute(routeName, flatConfig) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n  try {\n    for (var _iterator4 = flatConfig[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var config = _step4.value;\n      if (routeName === config.routeNames[config.routeNames.length - 1]) {\n        return config.parse;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nvar findInitialRoute = function findInitialRoute(routeName, parentScreens, initialRoutes) {\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n  try {\n    for (var _iterator5 = initialRoutes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var config = _step5.value;\n      if (parentScreens.length === config.parentScreens.length) {\n        var sameParents = true;\n        for (var i = 0; i < parentScreens.length; i++) {\n          if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n            sameParents = false;\n            break;\n          }\n        }\n        if (sameParents) {\n          return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nvar createStateObject = function createStateObject(initialRoute, route, isEmpty) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, route]\n      };\n    } else {\n      return {\n        routes: [route]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread({}, route, {\n          state: {\n            routes: []\n          }\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread({}, route, {\n          state: {\n            routes: []\n          }\n        })]\n      };\n    }\n  }\n};\nvar createNestedStateObject = function createNestedStateObject(path, routes, initialRoutes, flatConfig) {\n  var route = routes.shift();\n  var parentScreens = [];\n  var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n  parentScreens.push(route.name);\n  var state = createStateObject(initialRoute, route, routes.length === 0);\n  if (routes.length > 0) {\n    var nestedState = state;\n    while (route = routes.shift()) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n      var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state;\n      }\n      parentScreens.push(route.name);\n    }\n  }\n  route = findFocusedRoute(state);\n  route.path = path.replace(/\\/$/, '');\n  var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);\n  if (params) {\n    route.params = _objectSpread({}, route.params, params);\n  }\n  return state;\n};\nvar parseQueryParams = function parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var params = queryString.parse(query);\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n  return Object.keys(params).length ? params : undefined;\n};\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(getStateFromPath, \"getStateFromPath\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(cachedConfigResources, \"cachedConfigResources\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(getConfigResources, \"getConfigResources\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(prepareConfigResources, \"prepareConfigResources\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(getInitialRoutes, \"getInitialRoutes\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(getSortedNormalizedConfigs, \"getSortedNormalizedConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(checkForDuplicatedConfigs, \"checkForDuplicatedConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(getConfigsWithRegexes, \"getConfigsWithRegexes\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(matchAgainstConfigs, \"matchAgainstConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(createNormalizedConfigs, \"createNormalizedConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(createConfigItem, \"createConfigItem\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(findParseConfigForRoute, \"findParseConfigForRoute\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(findInitialRoute, \"findInitialRoute\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(createStateObject, \"createStateObject\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(createNestedStateObject, \"createNestedStateObject\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n  reactHotLoader.register(parseQueryParams, \"parseQueryParams\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getStateFromPath.js\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}