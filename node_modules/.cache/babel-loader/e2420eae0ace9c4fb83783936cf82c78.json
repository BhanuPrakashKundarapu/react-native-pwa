{"ast":null,"code":"\"use strict\";\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\nimport { NavigationContext, useRoute } from '@react-navigation/core';\nimport * as React from 'react';\n\nfunction getScrollableNode(ref) {\n  if (ref.current == null) {\n    return null;\n  }\n\n  if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {\n    // This is already a scrollable node.\n    return ref.current;\n  } else if ('getScrollResponder' in ref.current) {\n    // If the view is a wrapper like FlatList, SectionList etc.\n    // We need to use `getScrollResponder` to get access to the scroll responder\n    return ref.current.getScrollResponder();\n  } else if ('getNode' in ref.current) {\n    // When a `ScrollView` is wrapped in `Animated.createAnimatedComponent`\n    // we need to use `getNode` to get the ref to the actual scrollview.\n    // Note that `getNode` is deprecated in newer versions of react-native\n    // this is why we check if we already have a scrollable node above.\n    return ref.current.getNode();\n  } else {\n    return ref.current;\n  }\n}\n\nexport function useScrollToTop(ref) {\n  var navigation = React.useContext(NavigationContext);\n  var route = useRoute();\n\n  if (navigation === undefined) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n\n  React.useEffect(function () {\n    var tabNavigations = [];\n    var currentNavigation = navigation; // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them\n    // So we need to find all the parent tab navigators and add the listeners there\n\n    while (currentNavigation) {\n      if (currentNavigation.getState().type === 'tab') {\n        tabNavigations.push(currentNavigation);\n      }\n\n      currentNavigation = currentNavigation.getParent();\n    }\n\n    if (tabNavigations.length === 0) {\n      return;\n    }\n\n    var unsubscribers = tabNavigations.map(function (tab) {\n      return tab.addListener( // We don't wanna import tab types here to avoid extra deps\n      // in addition, there are multiple tab implementations\n      // @ts-expect-error the `tabPress` event is only available when navigation type is tab\n      'tabPress', function (e) {\n        // We should scroll to top only when the screen is focused\n        var isFocused = navigation.isFocused(); // In a nested stack navigator, tab press resets the stack to first screen\n        // So we should scroll to top only when we are on first screen\n\n        var isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key; // Run the operation in the next frame so we're sure all listeners have been run\n        // This is necessary to know if preventDefault() has been called\n\n        requestAnimationFrame(function () {\n          var scrollable = getScrollableNode(ref);\n\n          if (isFocused && isFirst && scrollable && !e.defaultPrevented) {\n            if ('scrollToTop' in scrollable) {\n              scrollable.scrollToTop();\n            } else if ('scrollTo' in scrollable) {\n              scrollable.scrollTo({\n                y: 0,\n                animated: true\n              });\n            } else if ('scrollToOffset' in scrollable) {\n              scrollable.scrollToOffset({\n                offset: 0,\n                animated: true\n              });\n            } else if ('scrollResponderScrollTo' in scrollable) {\n              scrollable.scrollResponderScrollTo({\n                y: 0,\n                animated: true\n              });\n            }\n          }\n        });\n      });\n    });\n    return function () {\n      unsubscribers.forEach(function (unsubscribe) {\n        return unsubscribe();\n      });\n    };\n  }, [navigation, ref, route.key]);\n}\n\n__signature__(useScrollToTop, \"useContext{navigation}\\nuseRoute{route}\\nuseEffect{}\", function () {\n  return [useRoute];\n});\n\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(getScrollableNode, \"getScrollableNode\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\native\\\\lib\\\\module\\\\useScrollToTop.js\");\n  reactHotLoader.register(useScrollToTop, \"useScrollToTop\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\native\\\\lib\\\\module\\\\useScrollToTop.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}