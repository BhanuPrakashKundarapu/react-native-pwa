{"ast":null,"code":"\"use strict\";\n\nimport _toConsumableArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\nimport * as queryString from 'query-string';\nimport { getPatternParts } from \"./getPatternParts.js\";\nimport { validatePathConfig } from \"./validatePathConfig.js\";\nvar getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\nvar cachedNormalizedConfigs = new WeakMap();\nvar getNormalizedConfigs = function getNormalizedConfigs(options) {\n  if (!options?.screens) return {};\n  var cached = cachedNormalizedConfigs.get(options?.screens);\n  if (cached) return cached;\n  var normalizedConfigs = createNormalizedConfigs(options.screens);\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n  return normalizedConfigs;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got '\".concat(String(state), \"' for the navigation state. You must pass a valid state object.\"));\n  }\n  if (options) {\n    validatePathConfig(options);\n  }\n  var configs = getNormalizedConfigs(options);\n  var path = '/';\n  var current = state;\n  var allParams = {};\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var parts = void 0;\n    var focusedParams = void 0;\n    var currentOptions = configs;\n    var focusedRoute = getActiveRoute(state);\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    var nestedRouteNames = [];\n    var hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      parts = currentOptions[route.name].parts;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        (function () {\n          var stringify = currentOptions[route.name]?.stringify;\n          var currentParams = Object.fromEntries(Object.entries(route.params).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              value = _ref2[1];\n            return [key, stringify?.[key] ? stringify[key](value) : String(value)];\n          }));\n          if (parts?.length) {\n            Object.assign(allParams, currentParams);\n          }\n          if (focusedRoute === route) {\n            // If this is the focused route, keep the params for later use\n            // We save it here since it's been stringified already\n            focusedParams = _objectSpread({}, currentParams);\n            parts\n            // eslint-disable-next-line no-loop-func\n            ?.forEach(function (_ref3) {\n              var param = _ref3.param;\n              if (param) {\n                // Remove the params present in the pattern since we'll only use the rest for query string\n                if (focusedParams) {\n                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                  delete focusedParams[param];\n                }\n              }\n            });\n          }\n        })();\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += parts?.map(function (_ref4) {\n        var segment = _ref4.segment,\n          param = _ref4.param,\n          optional = _ref4.optional;\n        // We don't know what to show for wildcard patterns\n        // Showing the route name seems ok, though whatever we show here will be incorrect\n        // Since the page doesn't actually exist\n        if (segment === '*') {\n          return route.name;\n        }\n\n        // If the path has a pattern for a param, put the param in the path\n        if (param) {\n          var value = allParams[param];\n          if (value === undefined && optional) {\n            // Optional params without value assigned in route.params should be ignored\n            return '';\n          }\n\n          // Valid characters according to\n          // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n          return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, function (char) {\n            return encodeURIComponent(char);\n          });\n        }\n        return encodeURIComponent(segment);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          key = _ref6[0],\n          value = _ref6[1];\n        return [key, String(value)];\n      }));\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (var param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n      var query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += \"?\".concat(query);\n      }\n    }\n    current = route.state;\n  };\n  while (current) {\n    _loop();\n  }\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = \"\".concat(options.path, \"/\").concat(path);\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // If path doesn't start with a slash, add it\n  // This makes sure that history.pushState will update the path correctly instead of appending\n  if (!path.startsWith('/')) {\n    path = \"/\".concat(path);\n  }\n  return path;\n}\nvar createConfigItem = function createConfigItem(config, parentParts) {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    var _parts = getPatternParts(config);\n    if (parentParts) {\n      return {\n        parts: [].concat(_toConsumableArray(parentParts), _toConsumableArray(_parts))\n      };\n    }\n    return {\n      parts: _parts\n    };\n  }\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  var parts = config.exact !== true ? [].concat(_toConsumableArray(parentParts || []), _toConsumableArray(config.path ? getPatternParts(config.path) : [])) : config.path ? getPatternParts(config.path) : undefined;\n  var screens = config.screens ? createNormalizedConfigs(config.screens, parts) : undefined;\n  return {\n    parts: parts,\n    stringify: config.stringify,\n    screens: screens\n  };\n};\nvar createNormalizedConfigs = function createNormalizedConfigs(options, parts) {\n  return Object.fromEntries(Object.entries(options).map(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n      name = _ref8[0],\n      c = _ref8[1];\n    var result = createConfigItem(c, parts);\n    return [name, result];\n  }));\n};\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(getActiveRoute, \"getActiveRoute\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getPathFromState.js\");\n  reactHotLoader.register(cachedNormalizedConfigs, \"cachedNormalizedConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getPathFromState.js\");\n  reactHotLoader.register(getNormalizedConfigs, \"getNormalizedConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getPathFromState.js\");\n  reactHotLoader.register(getPathFromState, \"getPathFromState\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getPathFromState.js\");\n  reactHotLoader.register(createConfigItem, \"createConfigItem\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getPathFromState.js\");\n  reactHotLoader.register(createNormalizedConfigs, \"createNormalizedConfigs\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\core\\\\lib\\\\module\\\\getPathFromState.js\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}