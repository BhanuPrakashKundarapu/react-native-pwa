{"ast":null,"code":"\"use strict\";\n\nimport _objectSpread from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\nimport { BaseNavigationContainer, getActionFromState, getPathFromState, getStateFromPath, ThemeProvider, validatePathConfig } from '@react-navigation/core';\nimport * as React from 'react';\nimport { I18nManager } from 'react-native';\nimport useLatestCallback from 'use-latest-callback';\nimport { LinkingContext } from \"./LinkingContext.js\";\nimport { LocaleDirContext } from \"./LocaleDirContext.js\";\nimport { DefaultTheme } from \"./theming/DefaultTheme.js\";\nimport { UnhandledLinkingContext } from \"./UnhandledLinkingContext.js\";\nimport { useBackButton } from './useBackButton';\nimport { useDocumentTitle } from './useDocumentTitle';\nimport { useLinking } from './useLinking';\nimport { useThenable } from \"./useThenable.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nglobalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\n/**\n * Container component which holds the navigation state designed for React Native apps.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).\n * @param props.onReady Callback which is called after the navigation tree mounts.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.onUnhandledAction Callback which is called when an action is not handled.\n * @param props.direction Text direction of the components. Defaults to `'ltr'`.\n * @param props.theme Theme object for the UI elements.\n * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.\n * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.\n * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nfunction NavigationContainerInner(_ref, ref) {\n  var _ref$direction = _ref.direction,\n    direction = _ref$direction === void 0 ? I18nManager.getConstants().isRTL ? 'rtl' : 'ltr' : _ref$direction,\n    _ref$theme = _ref.theme,\n    theme = _ref$theme === void 0 ? DefaultTheme : _ref$theme,\n    linking = _ref.linking,\n    _ref$fallback = _ref.fallback,\n    fallback = _ref$fallback === void 0 ? null : _ref$fallback,\n    documentTitle = _ref.documentTitle,\n    onReady = _ref.onReady,\n    onStateChange = _ref.onStateChange,\n    rest = _objectWithoutProperties(_ref, [\"direction\", \"theme\", \"linking\", \"fallback\", \"documentTitle\", \"onReady\", \"onStateChange\"]);\n  var isLinkingEnabled = linking ? linking.enabled !== false : false;\n  if (linking?.config) {\n    validatePathConfig(linking.config);\n  }\n  var refContainer = React.useRef(null);\n  useBackButton(refContainer);\n  useDocumentTitle(refContainer, documentTitle);\n  var _React$useState = React.useState(),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    lastUnhandledLink = _React$useState2[0],\n    setLastUnhandledLink = _React$useState2[1];\n  var _useLinking = useLinking(refContainer, _objectSpread({\n      enabled: isLinkingEnabled,\n      prefixes: []\n    }, linking), setLastUnhandledLink),\n    getInitialState = _useLinking.getInitialState;\n  var linkingContext = React.useMemo(function () {\n    return {\n      options: linking\n    };\n  }, [linking]);\n  var unhandledLinkingContext = React.useMemo(function () {\n    return {\n      lastUnhandledLink: lastUnhandledLink,\n      setLastUnhandledLink: setLastUnhandledLink\n    };\n  }, [lastUnhandledLink, setLastUnhandledLink]);\n  var onReadyForLinkingHandling = useLatestCallback(function () {\n    // If the screen path matches lastUnhandledLink, we do not track it\n    var path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink(function (previousLastUnhandledLink) {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onReady?.();\n  });\n  var onStateChangeForLinkingHandling = useLatestCallback(function (state) {\n    // If the screen path matches lastUnhandledLink, we do not track it\n    var path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink(function (previousLastUnhandledLink) {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onStateChange?.(state);\n  });\n  // Add additional linking related info to the ref\n  // This will be used by the devtools\n  React.useEffect(function () {\n    if (refContainer.current) {\n      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n        get linking() {\n          return _objectSpread({}, linking, {\n            enabled: isLinkingEnabled,\n            prefixes: linking?.prefixes ?? [],\n            getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n            getPathFromState: linking?.getPathFromState ?? getPathFromState,\n            getActionFromState: linking?.getActionFromState ?? getActionFromState\n          });\n        }\n      });\n    }\n  });\n  var _useThenable = useThenable(getInitialState),\n    _useThenable2 = _slicedToArray(_useThenable, 2),\n    isResolved = _useThenable2[0],\n    initialState = _useThenable2[1];\n  React.useImperativeHandle(ref, function () {\n    return refContainer.current;\n  });\n  var isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;\n  if (!isLinkingReady) {\n    // This is temporary until we have Suspense for data-fetching\n    // Then the fallback will be handled by a parent `Suspense` component\n    return /*#__PURE__*/_jsx(ThemeProvider, {\n      value: theme,\n      children: fallback\n    });\n  }\n  return /*#__PURE__*/_jsx(LocaleDirContext.Provider, {\n    value: direction,\n    children: /*#__PURE__*/_jsx(UnhandledLinkingContext.Provider, {\n      value: unhandledLinkingContext,\n      children: /*#__PURE__*/_jsx(LinkingContext.Provider, {\n        value: linkingContext,\n        children: /*#__PURE__*/_jsx(BaseNavigationContainer, _objectSpread({}, rest, {\n          theme: theme,\n          onReady: onReadyForLinkingHandling,\n          onStateChange: onStateChangeForLinkingHandling,\n          initialState: rest.initialState == null ? initialState : rest.initialState,\n          ref: refContainer\n        }))\n      })\n    })\n  });\n}\n__signature__(NavigationContainerInner, \"useRef{refContainer}\\nuseBackButton{}\\nuseDocumentTitle{}\\nuseState{[lastUnhandledLink, setLastUnhandledLink]}\\nuseLinking{{\\n    getInitialState\\n  }}\\nuseMemo{linkingContext}\\nuseMemo{unhandledLinkingContext}\\nuseLatestCallback{onReadyForLinkingHandling}\\nuseLatestCallback{onStateChangeForLinkingHandling}\\nuseEffect{}\\nuseThenable{[isResolved, initialState]}\\nuseImperativeHandle{}\", function () {\n  return [useBackButton, useDocumentTitle, useLinking, useLatestCallback, useLatestCallback, useThenable, React.useImperativeHandle];\n});\nexport var NavigationContainer = /*#__PURE__*/React.forwardRef(NavigationContainerInner);\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(NavigationContainerInner, \"NavigationContainerInner\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\native\\\\lib\\\\module\\\\NavigationContainer.js\");\n  reactHotLoader.register(NavigationContainer, \"NavigationContainer\", \"D:\\\\Vscode\\\\MERNPROJECTS\\\\Pwa reference\\\\react-native-pwa\\\\react-native-pwa\\\\node_modules\\\\@react-navigation\\\\native\\\\lib\\\\module\\\\NavigationContainer.js\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":null,"metadata":{},"sourceType":"module"}